from __future__ import annotations

from typing import Dict, List, Tuple
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton


def _add_to_cart_button(item: Dict) -> InlineKeyboardButton | None:
    pid = item.get("id")
    if not pid:
        return None
    return InlineKeyboardButton(
        text=f"‚ûï –í –∫–æ—Ä–∑–∏–Ω—É: {item.get('brand','')} {item.get('name','')}",
        callback_data=f"cart:add:{pid}",
    )


def _price_row(it: Dict) -> str:
    value = int(it.get("price") or 0)
    currency = it.get("price_currency") or "‚ÇΩ"
    # –í —Ç–µ—Å—Ç–∞—Ö –æ–∂–∏–¥–∞–µ—Ç—Å—è —Å–∏–º–≤–æ–ª ‚ÇΩ —Ä—è–¥–æ–º —Å —á–∏—Å–ª–æ–º
    if currency in ("RUB", "‚ÇΩ"):
        return f"{value} ‚ÇΩ"
    return f"{value} {currency}"


def _rows(items: List[Dict]) -> List[str]:
    lines: List[str] = []
    for it in items:
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏—Å—Ç–æ—á–Ω–∏–∫–µ
        source_name = it.get('source_name', '')
        source_mark = f" üè™ {source_name}" if source_name else ""
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—É
        alt_reason = it.get('alternative_reason', '')
        alt_mark = ""
        if alt_reason == "–¥—Ä—É–≥–æ–π_–≤–∞—Ä–∏–∞–Ω—Ç_—Ç–æ–≤–∞—Ä–∞":
            alt_mark = " üîÑ"
        elif alt_reason == "–∞–Ω–∞–ª–æ–≥_–∫–∞—Ç–µ–≥–æ—Ä–∏–∏":
            alt_mark = " üîÄ"
        elif alt_reason == "—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π_–≤–∞—Ä–∏–∞–Ω—Ç":
            alt_mark = " ‚≠ê"
        
        lines.append(f"‚Äî {it.get('brand','')} {it.get('name','')}{alt_mark} ‚Äî {_price_row(it)}{source_mark}")
    return lines


def _noop_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="noop")]]
    )


def render_skincare_report(result: Dict) -> Tuple[str, InlineKeyboardMarkup]:
    print(f"üß¥ render_skincare_report called with result keys: {list(result.keys())}")
    s = result.get("skincare", {})
    print(f"üß¥ Skincare data keys: {list(s.keys()) if s else 'No skincare data'}")
    
    # CRITICAL FIX: Use ENGLISH keys that actually come from SelectorV2
    # –î–∞–Ω–Ω—ã–µ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å –∞–Ω–≥–ª–∏–π—Å–∫–∏–º–∏ –∫–ª—é—á–∞–º–∏ –∏–∑ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞
    cleanser = s.get("cleanser", [])
    toner = s.get("toner", [])
    serum = s.get("serum", [])
    moisturizer = s.get("moisturizer", [])
    eye_cream = s.get("eye_cream", [])  # Keep technical key for data access
    sunscreen = s.get("sunscreen", [])
    mask = s.get("mask", [])
    
    print(f"üß¥ Found products: cleanser={len(cleanser)}, toner={len(toner)}, serum={len(serum)}, moisturizer={len(moisturizer)}, eye_cream={len(eye_cream)}, sunscreen={len(sunscreen)}, mask={len(mask)}")
    
    # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏—é –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∏ –ø–æ–∏—Å–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
    from engine.source_resolver import enhance_product_with_source_info
    
    # Enhance products with source info and alternatives
    enhanced_cleanser = [enhance_product_with_source_info(p) for p in cleanser]
    enhanced_toner = [enhance_product_with_source_info(p) for p in toner]
    enhanced_serum = [enhance_product_with_source_info(p) for p in serum]
    enhanced_moisturizer = [enhance_product_with_source_info(p) for p in moisturizer]
    enhanced_eye_cream = [enhance_product_with_source_info(p) for p in eye_cream]
    enhanced_sunscreen = [enhance_product_with_source_info(p) for p in sunscreen]
    enhanced_mask = [enhance_product_with_source_info(p) for p in mask]
    
    # Organize into AM/PM/Weekly for display
    am = enhanced_cleanser + enhanced_toner + enhanced_serum + enhanced_moisturizer + enhanced_sunscreen  # Morning routine
    pm = enhanced_cleanser + enhanced_serum + enhanced_moisturizer + enhanced_eye_cream  # Evening routine  
    wk = enhanced_mask  # Weekly treatments

    text_lines: List[str] = [
        "üìã –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π —É—Ö–æ–¥",
        "",
        "üåÖ **–£–¢–†–û–ú (AM):**",
        *(_rows(am) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "üåô **–í–ï–ß–ï–†–û–ú (PM):**",
        *(_rows(pm) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "üìÖ **–ï–ñ–ï–ù–ï–î–ï–õ–¨–ù–û:**",
        *(_rows(wk) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "**üõçÔ∏è –í—ã–±—Ä–∞—Ç—å —Ç–æ–≤–∞—Ä—ã:**",
        "‚Ä¢ üè™ –∏—Å—Ç–æ—á–Ω–∏–∫ —Ç–æ–≤–∞—Ä–∞", 
        "‚Ä¢ üîÑ –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç",
        "‚Ä¢ üîÄ –∞–Ω–∞–ª–æ–≥ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        "‚Ä¢ ‚≠ê —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤—ã–±–æ—Ä"
    ]

    all_products = [*(am or []), *(pm or []), *(wk or [])]

    # CRITICAL FIX: Create cart buttons based on product ID, not ref_link
    # Even if ref_link is missing, we can still add products to cart
    products_with_id = [p for p in all_products if p.get("id")]
    print(f"üÜî Skincare products with ID: {len(products_with_id)}")

    buttons: List[List[InlineKeyboardButton]] = []

    # Add cart buttons for first 8 products
    for product in products_with_id[:8]:
        atc = _add_to_cart_button(product)
        if atc:
            buttons.append([atc])

    # Add "Show All" button if we have many products
    if len(products_with_id) > 8:
        buttons.append([InlineKeyboardButton(
            text=f"üõçÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã ({len(products_with_id)})",
            callback_data="skincare:show_all"
        )])

    # ALWAYS: Add "Go to Cart" button if we have any products
    if products_with_id:
        buttons.append([InlineKeyboardButton(
            text="üõí –ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–æ—Ä–∑–∏–Ω—É",
            callback_data="show_cart"
        )])

    # Debug ref_link issue
    ref_link_products = [p for p in all_products if p.get("ref_link")]
    print(f"üåê Skincare products with ref_link: {len(ref_link_products)}")
    if not ref_link_products and products_with_id:
        print("‚ö†Ô∏è Skincare products have IDs but no ref_links - check affiliate link generation")
        if products_with_id:
            sample_product = products_with_id[0]
            print(f"üìù Sample skincare product: id={sample_product.get('id')}, link={sample_product.get('link')}, ref_link={sample_product.get('ref_link')}")

    # Return keyboard or noop
    if buttons:
        print(f"üõí Created {len(buttons)} total skincare buttons")
        kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    else:
        print("‚ö†Ô∏è No skincare products with ID found, returning noop keyboard")
        kb = _noop_keyboard()

    return "\n".join(text_lines), kb


def render_makeup_report(result: Dict) -> Tuple[str, InlineKeyboardMarkup]:
    print(f"üé® render_makeup_report called with result keys: {list(result.keys())}")
    m = result.get("makeup", {})
    print(f"üíÑ Makeup data keys: {list(m.keys()) if m else 'No makeup data'}")
    
    # CRITICAL DEBUG: Show all makeup categories and their content counts
    if m:
        print("üîç DETAILED MAKEUP ANALYSIS:")
        for key, products in m.items():
            count = len(products) if products else 0
            print(f"  üì¶ EXACT KEY '{key}': {count} products")
            if products and count > 0:
                print(f"      First product: {products[0].get('name', 'No name')}")
        
        # CRITICAL: Let's use the ACTUAL keys that exist in the data
        print("üéØ USING ACTUAL KEYS FROM SELECTOR:")
        actual_keys = list(m.keys())
        print(f"Available keys: {actual_keys}")
    else:
        print("‚ùå No makeup data to analyze")
    
    # Map SelectorV2 categories to display groups
    # CRITICAL: SelectorV2 returns in CAPITALIZED keys: "–¢–æ–Ω–∞–ª—å–Ω—ã–π –∫—Ä–µ–º", "–ë—Ä–æ–≤–∏", "–ü–æ–º–∞–¥–∞", "–¢—É—à—å", "–¢–µ–Ω–∏ –¥–ª—è –≤–µ–∫"
    face_categories = ['–æ—Å–Ω–æ–≤–∞', '–∫–æ–Ω—Å–∏–ª–µ—Ä', '–∫–æ—Ä—Ä–µ–∫—Ç–æ—Ä', '–ø—É–¥—Ä–∞', '—Ä—É–º—è–Ω–∞', '–±—Ä–æ–Ω–∑–∞—Ç–æ—Ä', '–∫–æ–Ω—Ç—É—Ä', '—Ö–∞–π–ª–∞–π—Ç–µ—Ä', '–¢–æ–Ω–∞–ª—å–Ω—ã–π –∫—Ä–µ–º']
    brows_categories = ['–±—Ä–æ–≤–∏', '–ë—Ä–æ–≤–∏']  
    eyes_categories = ['—Ç—É—à—å –¥–ª—è —Ä–µ—Å–Ω–∏—Ü', '–¢–µ–Ω–∏ –¥–ª—è –≤–µ–∫', '–ø–æ–¥–≤–æ–¥–∫–∞ –¥–ª—è –≥–ª–∞–∑', '–¢—É—à—å']
    lips_categories = ['–ø–æ–º–∞–¥–∞', '–±–ª–µ—Å–∫ –¥–ª—è –≥—É–±', 'lip_liner', '–ü–æ–º–∞–¥–∞']
    
    print(f"üîç Looking for face categories: {face_categories}")
    print(f"üîç Looking for brows categories: {brows_categories}")
    print(f"üîç Looking for eyes categories: {eyes_categories}")
    print(f"üîç Looking for lips categories: {lips_categories}")
    
    # SIMPLIFIED: Just use ALL available products from makeup data
    face = []
    brows = []
    eyes = []
    lips = []
    
    # If we have makeup data, distribute all products to appropriate categories
    if m:
        print("üéØ SIMPLIFIED APPROACH: Using all available makeup products")
        all_makeup_products = []
        for key, products in m.items():
            if products:
                print(f"üì¶ Adding {len(products)} products from '{key}'")
                all_makeup_products.extend(products)
        
        # Distribute products based on their category field
        for product in all_makeup_products:
            category = str(product.get('category', '')).lower()
            print(f"üîç Product category: '{category}' -> {product.get('name', 'No name')}")
            
            # Face products
            if any(term in category for term in ['—Ç–æ–Ω–∞–ª—å–Ω', '–æ—Å–Ω–æ–≤', '–∫–æ–Ω—Å–∏–ª', '–ø—É–¥—Ä', '—Ä—É–º—è–Ω', 'foundation', 'concealer', 'powder', 'blush']):
                face.append(product)
            # Brow products  
            elif any(term in category for term in ['–±—Ä–æ–≤', 'eyebrow', 'brow']):
                brows.append(product)
            # Eye products
            elif any(term in category for term in ['—Ç—É—à—å', '—Ç–µ–Ω–∏', '–ø–æ–¥–≤–æ–¥–∫', 'mascara', 'eyeshadow', 'eyeliner']):
                eyes.append(product)
            # Lip products
            elif any(term in category for term in ['–ø–æ–º–∞–¥', '–±–ª–µ—Å–∫', 'lipstick', 'lip']):
                lips.append(product)
            else:
                # Default to face if category unclear
                face.append(product)
    
    # Products already distributed above in the simplified approach
    else:
        # No makeup data available
        print("‚ùå No makeup data - using empty lists")
    
    print(f"üõçÔ∏è Products count: face={len(face)}, brows={len(brows)}, eyes={len(eyes)}, lips={len(lips)}")

    text_lines: List[str] = [
        "üé® –ú–∞–∫–∏—è–∂ –ø–æ –ø–∞–ª–∏—Ç—Ä–µ",
        "",
        "üíã **–õ–ò–¶–û:**",
        *(_rows(face) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "ü§® **–ë–†–û–í–ò:**",
        *(_rows(brows) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "üëÅÔ∏è **–ì–õ–ê–ó–ê:**",
        *(_rows(eyes) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "üíÑ **–ì–£–ë–´:**",
        *(_rows(lips) or ["‚Äî –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤"]),
        "",
        "**üõçÔ∏è –í—ã–±—Ä–∞—Ç—å —Ç–æ–≤–∞—Ä—ã:**",
        "‚Ä¢ üè™ –∏—Å—Ç–æ—á–Ω–∏–∫ —Ç–æ–≤–∞—Ä–∞", 
        "‚Ä¢ üîÑ –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç",
        "‚Ä¢ üîÄ –∞–Ω–∞–ª–æ–≥ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        "‚Ä¢ ‚≠ê —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤—ã–±–æ—Ä"
    ]

    all_products = [*(face or []), *(brows or []), *(eyes or []), *(lips or [])]
    print(f"üõçÔ∏è Total makeup products for buttons: {len(all_products)}")
    
    # CRITICAL FIX: Create cart buttons based on product ID, not ref_link
    # Even if ref_link is missing, we can still add products to cart
    products_with_id = [p for p in all_products if p.get("id")]
    print(f"üÜî Products with ID: {len(products_with_id)}")
    
    buttons: List[List[InlineKeyboardButton]] = []
    
    # Add cart buttons for first 8 products
    for product in products_with_id[:8]:
        atc = _add_to_cart_button(product)
        if atc:
            buttons.append([atc])
    
    # Add "Show All" button if we have many products
    if len(products_with_id) > 8:
        buttons.append([InlineKeyboardButton(
            text=f"üõçÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ç–æ–≤–∞—Ä—ã ({len(products_with_id)})",
            callback_data="makeup:show_all"
        )])
    
    # ALWAYS: Add "Go to Cart" button if we have any products
    if products_with_id:
        buttons.append([InlineKeyboardButton(
            text="üõí –ü–µ—Ä–µ–π—Ç–∏ –≤ –∫–æ—Ä–∑–∏–Ω—É", 
            callback_data="show_cart"
        )])
    
    # Debug ref_link issue
    ref_link_products = [p for p in all_products if p.get("ref_link")]
    print(f"üåê Products with ref_link: {len(ref_link_products)}")
    if not ref_link_products and products_with_id:
        print("‚ö†Ô∏è Products have IDs but no ref_links - check affiliate link generation")
        sample_product = products_with_id[0]
        print(f"üìù Sample product: id={sample_product.get('id')}, link={sample_product.get('link')}, ref_link={sample_product.get('ref_link')}")
    
    # Return keyboard or noop
    if buttons:
        print(f"üõí Created {len(buttons)} total buttons")
        kb = InlineKeyboardMarkup(inline_keyboard=buttons)
    else:
        print("‚ö†Ô∏è No products with ID found, returning noop keyboard")
        kb = _noop_keyboard()
        
    return "\n".join(text_lines), kb
